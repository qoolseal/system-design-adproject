## 1) Аутентификация и авторизация

**Что выбираем**
- **Протокол**: **OAuth 2.1 + OpenID Connect (OIDC)**.
    - Для веб/мобилок — **Authorization Code + PKCE** (без имплисит/парольных грантов).
    - Для сервис-к-сервису — **Client Credentials**.
- **Токены**: **JWT** (RS256/ES256), короткоживущие **access token** + **refresh token** с ротацией.
- **Хранилище ключей**: JWKS-эндпоинт; ключи подписания с **rotation** (kid), секреты — в Vault.
- **Где проверяем**: на **API-шлюзе** (ингресс) и в сервисах (lib/sidecar).
- **Модель прав**: **гибрид RBAC + ABAC** (роли + атрибуты/условия), движок политик — **OPA (Open Policy Agent)**. Кеш политик в Redis.

**Почему**
- OAuth2.1/OIDC — стандарт де-факто для браузеров/мобильных, дружит со SSO.
- JWT позволяют автономно проверять доступы (низкая латентность) и легко внедрять **scopes/claims**.
- PKCE защищает публичных клиентов. Ротация refresh-токенов снижает риск угонов.
- Гибрид RBAC/ABAC закрывает как «роль админ/пользователь», так и тонкие правила (владелец объекта, время, регион).

**Как выдаём/проверяем**
- Login → Authorization Code (+PKCE) → IdP (Keycloak/Auth0/ORY).
- IdP выдаёт `id_token` (OIDC), `access_token` (JWT, 5–15 мин), `refresh_token` (в httpOnly, Secure, SameSite=strict cookie).
- API-шлюз валидирует подпись JWT по JWKS, проверяет `exp/aud/iss`, **scopes**.
- Ротация refresh: при каждом обновлении — новый refresh, старый гасим (token reuse detection).

**Истечение/отзыв**
- Короткий срок жизни access-токена + «deny-list» по `jti` для критических отзывов.
- Принудительный logout: пометка `jti` в Redis до `exp`.
- Ключи подписания — плановая ротация; сервисы подтягивают JWKS по `kid`.

---
## 2) Безопасность передачи данных

**Что выбираем**
- **TLS 1.2/1.3** везде (внешний трафик и «внутри» между сервисами).
- **HSTS**, **OCSP stapling**, **PFS** (ECDHE), современный набор шифров.
- **mTLS** для внутреннего трафика (east-west) через **service mesh** (Istio/Linkerd) или SPIFFE/SPIRE.
- **Шифрование «поверх TLS»** для чувствительных полей (PII) — **Vault Transit (AES-GCM 256)**, envelope-подход.

**Что шифруем дополнительно**
- Персональные поля (паспорт/ИНН, адреса, телефоны — если это PII), токены интеграций, секреты сессий.
- В БД — **колоночное/полевое шифрование** + шифрование томов (LUKS/dm-crypt).
- Платёжные данные не храним (PCI-вне), используем токенизацию провайдера.

**Почему**
- HSTS/PFS — защита от даунгрейда/перехватов.
- mTLS — недоверие к внутренней сети, mutual auth сервисов.
- Доп. шифрование полей = защита при компрометации БД/дампов.

---
## 3) Управление доступами (RBAC/ABAC)

**Что выбираем**
- **RBAC**: роли `ADMIN`, `USER`, `MODERATOR`, `SERVICE`.
- **ABAC**: политики «владелец ресурса», «организация/регион», «в рабочее время», «статус объекта».
- **Движок**: **OPA** (Rego) или аналог (Cedar/OPA-подобный), хранение политик в Git (GitOps), доставка — через CI/CD.

**Процессы**
- Создание/изменение ролей — через административный UI, изменения политик — PR в репозиторий политик (code review + авто-тесты).
- Периодическая **ревизия доступов** (access review), отчёты по отклонениям.
- Автоматическая проверка политик в CI (unit-тесты на Rego, тестовые кейсы на реальные объекты).

**Почему**
- RBAC закрывает «грубые» уровни, ABAC даёт тонкую грануляцию без взрывного роста ролей.
- GitOps для политик = трассируемость и контроль изменений.

---
## 4) Хранение и управление секретами

**Что выбираем**
- **HashiCorp Vault**:
    - **Kubernetes auth** (ServiceAccount → Vault policy).
    - **KV v2** для конфиг-секретов; **Transit** для криптоопераций;
    - **Dynamic Secrets** для БД/облаков (временные логин/пароль).
    - **Auto-unseal**, аудит (журналы).
- Интеграция: **Vault Agent Injector / CSI** для подстановки секретов в поды.

**Ротация/шифрование конфигов**
- Регламент ротации: API-ключи — 90 дней, JWT-ключи — 30–60 дней, DB-пароли — динамически (часы).
- Конфиги в Git — без секретов; используем SOPS или шаблоны, секреты подтягиваются на деплое из Vault.
- Ключи шифрования хранятся в Vault; приложения вызывают Transit для шифр/дешифр.

**Почему**
- Vault даёт централизованный контроль, краткоживущие креды и трассируемость доступа.

---
## 5) Мониторинг и аудит безопасности

**Что собираем**
- **События аутентификации**: успешные/неуспешные логины, MFA, блокировки.
- **Авторизация**: отказы 403/401, срабатывания политик OPA (решения/вводные).
- **Доступ к чувствительным данным**: кто/когда/что, объём выгрузок.
- **Админ-действия**: смена ролей, публикация политик, изменения конфигов.
- **Секреты/Vault**: чтение/выдача/ротация, ошибки доступа.
- **TLS/mTLS**: ошибки рукопожатий, истечение сертификатов.
- **Аномалии**: нехарактерные IP/гео, частые ошибки входа, резкий рост выдач данных.

**Инструменты**
- **Prometheus/Grafana** — метрики доступа/ошибок.
- **ELK/Loki** — централизованные логи (структурированные, с `trace_id`, `user_id`).
- **OpenTelemetry + Jaeger** — трассировка с «безопасными» спанами (без PII).
- **SIEM** (Wazuh/Splunk/ELK-SIEM) — корреляция событий, правила оповещений.
- **Alertmanager** — алерты: рост 401/403, всплеск логинов, падение мTLS, аномальный `data export`.

**Почему**
- Видимость и трассируемость — единственный способ быстро ловить утечки и инсайдеров, плюс требования комплаенса.