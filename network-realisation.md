### Общая схема
- **Синхронные вызовы**: только когда нужен немедленный ответ (карточка объявления, создание заказа, авторизация).
- **Асинхронные события**: всё что может подождать — через Kafka (сага «заказ-оплата-доставка»).
- **Клиентские обновления в реальном времени**: WebSocket/SSE-подписки для браузеров и мобильных приложений (статусы заказа, прогресс доставки, уведомления)
### Конкретные случаи использования
#### REST (HTTP/2)
Используется там, где важна совместимость, кэшируемость и понятная URL-структура, а также для интеграций с внешними системами:
- клиент <-> API Gateway (REST + JSON)
- API Gateway <-> ad-service / user-service / search-service: REST для CRUD/поиска (кешируемые GET, понятные URL)
- media-service: загрузка клиентом в объектное хранилище
- report-service: получение жалоб от пользователей в синхронном режиме, автоматическое отображение "ваша заявка в обработке"

Используем версию **HTTP/2**
- Даст мультиплексирование по одному TCP-соединению, компрессию заголовков (HPACK), приоритетизацию потоков — это ускорит поиск и снизит накладные расходы на установку соединений
- API Gateway может на внешнем интерфейсе поддерживать **HTTP/3** для ускорения первого запроса и работы при высоких потерях пакетов (мобильные клиенты)

Собираем метрики: RPS, ошибки по кодам, латентности P50/P90/P99, retry rate, кэш-хиты.
#### gRPC (HTTP/2)
Используем для межсервисных взаимодействий
- **order-service <-> payment-service**
	- низкая латентность, строгая схема платежных команд, контроль дедлайнов (таймауты важны)
	- синхронно подтверждаем, что платёж "в работе" - unary режим
	- дополнительно можно стримить поток обновлений статуса платежа (аналог событиям в кафка в данном случае)
- **order-service <-> delivery-service (интеграционный адаптер)**
	- delivery-service - маппинг запросов в API курьерской службы
	- операции создания и отмены отправления запущены во внешней службе - unary
	- так же стримить можно этапы доставки
- **notification-service (внутренний API для триггеров)**
	- лёгкие серверные вызовы из разных сервисов (order/payment/delivery) для синхронной постановки задачи на рассылку/шаблонизацию
	- например, из payment-service - оплата не прошла
	  order-service - задача: отправить email c id заказа и примерными сроками доставки
**Надёжность:** дедлайны (таймауты), retries с экспоненциальным откатом, circuit breaker, идемпотентные ключи в metadata.
#### WebSockets(или SSE)
Используем для трансляции статусов заказов и личных уведомлений пользователям. В текущем сценарии используется только "сервер -> клиент", поэтому можно заменить WebSockets на SSE
- Kafka events -> notification-service -> WS -> клиент
- notification-service читает события в кафке, фильтрует и преобразует в обновления
**Обоснование выбора:**
- WebSocket позволяет поддерживать постоянное соединение с минимальными накладными расходами на установку, обеспечивая мгновенную доставку данных.
- Масштабирование достигается через централизованное хранилище состояния подписок (Redis pub/sub)
**Надёжность:** ping, автоматические реконнекты, ограничение размера сообщений, фильтрация тем на сервере.
### Безопасность и обсервабилити
- TLS 1.2+/mTLS между сервисами (gRPC).
- JWT для REST-запросов и авторизация WS при рукопожатии.
- OpenAPI для REST и `.proto` для gRPC.
- Логирование и трассировка (W3C Trace-Context, gRPC metadata).
- Метрики для всех каналов (latency, error rate, throughput).