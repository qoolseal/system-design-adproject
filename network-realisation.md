- **Синхронные вызовы**: только когда нужен немедленный ответ (карточка объявления, создание заказа, авторизация).
- **Асинхронные события**: всё что может подождать — через Kafka (сага «заказ-оплата-доставка» и т.п.).
- **Клиентские обновления в реальном времени**: WebSocket/WS-подписки из браузера/мобилки (статусы заказа, прогресс доставки, уведомления)
### Конкретные случаи использования
#### REST (HTTP/2)
Используется при взаимодействии:
- клиент <-> API Gateway (REST + JSON)
- API Gateway <-> ad-service / user-service / search-service: REST для CRUD/поиска (кешируемые GET, понятные URL)
- media-service: загрузка клиентом в объектное хранилище
- report-service: получение жалоб от пользователей в синхронном режиме, автоматическое отображение "ваша заявка в обработке"

Используем версию **HTTP/2**
- Даст мультиплексирование по одному TCP-соединению, компрессию заголовков (HPACK), приоритетизацию потоков — это ускорит поиск и снизит накладные расходы на установку соединений.

Собираем метрики: RPS, ошибки по кодам, латентности P50/P90/P99, retry rate, кэш-хиты.
#### gRPC
Используем для межсервисных взаимодействий
- **order-service <-> payment-service**
	- низкая латентность, строгая схема платежных команд, контроль дедлайнов (таймауты важны)
	- синхронно подтверждаем, что платёж "в работе" - unary режим
	- дополнительно можно стримить поток обновлений статуса платежа (аналог событиям в кафка в данном случае)
- **order-service <-> delivery-service (интеграционный адаптер)**
	- delivery-service - маппинг запросов в API курьерской службы
	- операции создания и отмены отправления запущены во внешней службе - unar
	- так же стримить можно этапы доставки
- **notification-service (внутренний API для триггеров)**
	- лёгкие серверные вызовы из разных сервисов (order/payment/delivery) для синхронной постановки задачи на рассылку/шаблонизацию
	- например, из payment-service - оплата не прошла
	  order-service - задача: отправить email c id заказа и примерными сроками доставки
#### WebSockets
Используем для трансляции статусов заказов и личных уведомлений пользователям. Однонаправленный канал, поэтому можно заменить WebSockets на SSE
- Kafka events -> notification-service -> WS
- notification-service читает события в кафке, фильтрует и преобразует в обновления