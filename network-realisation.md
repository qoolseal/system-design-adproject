### Общая схема
- **Синхронные вызовы**: только когда нужен немедленный ответ (карточка объявления, создание заказа, авторизация).
- **Асинхронные события**: всё что может подождать — через Kafka (сага «заказ-оплата-доставка»).
- **Клиентские обновления в реальном времени**: WebSocket/SSE-подписки для браузеров и мобильных приложений (статусы заказа, прогресс доставки, уведомления)
### Конкретные случаи использования
#### REST (HTTP/2)
Используется там, где важна совместимость, кэшируемость и понятная URL-структура, а также для интеграций с внешними системами:
- клиент <-> API Gateway (REST + JSON)
- API Gateway <-> ad-service / user-service / search-service: REST для CRUD/поиска (кешируемые GET, понятные URL)
- media-service: загрузка клиентом в объектное хранилище
- report-service: получение жалоб от пользователей в синхронном режиме, автоматическое отображение "ваша заявка в обработке"

Используем версию **HTTP/2**
- Даст мультиплексирование по одному TCP-соединению, компрессию заголовков (HPACK), приоритетизацию потоков — это ускорит поиск и снизит накладные расходы на установку соединений
- API Gateway может на внешнем интерфейсе поддерживать **HTTP/3** для ускорения первого запроса и работы при высоких потерях пакетов (мобильные клиенты)

Собираем метрики: RPS, ошибки по кодам, латентности P50/P90/P99, retry rate, кэш-хиты.
#### gRPC (HTTP/2)
Используем для межсервисных взаимодействий
- **order-service <-> payment-service**
	- низкая латентность, строгая схема платежных команд, контроль дедлайнов (таймауты важны)
	- синхронно подтверждаем, что платёж "в работе" - unary режим
	- дополнительно можно стримить поток обновлений статуса платежа (аналог событиям в кафка в данном случае)
- **order-service <-> delivery-service (интеграционный адаптер)**
	- delivery-service - маппинг запросов в API курьерской службы
	- операции создания и отмены отправления запущены во внешней службе - unary
	- так же стримить можно этапы доставки
- **notification-service (внутренний API для триггеров)**
	- лёгкие серверные вызовы из разных сервисов (order/payment/delivery) для синхронной постановки задачи на рассылку/шаблонизацию
	- например, из payment-service - оплата не прошла
	  order-service - задача: отправить email c id заказа и примерными сроками доставки
**Надёжность:** дедлайны (таймауты), retries с экспоненциальным откатом, circuit breaker, идемпотентные ключи в metadata.
#### WebSockets(или SSE)
Используем для трансляции статусов заказов и личных уведомлений пользователям. В текущем сценарии используется только "сервер -> клиент", поэтому можно заменить WebSockets на SSE
- Kafka events -> notification-service -> WS -> клиент
- notification-service читает события в кафке, фильтрует и преобразует в обновления
**Обоснование выбора:**
- WebSocket позволяет поддерживать постоянное соединение с минимальными накладными расходами на установку, обеспечивая мгновенную доставку данных.
- Масштабирование достигается через централизованное хранилище состояния подписок (Redis pub/sub)
**Надёжность:** ping, автоматические реконнекты, ограничение размера сообщений, фильтрация тем на сервере.
### Безопасность и обсервабилити
- TLS 1.2+/mTLS между сервисами (gRPC).
- JWT для REST-запросов и авторизация WS при рукопожатии.
- OpenAPI для REST и `.proto` для gRPC.
- Логирование и трассировка (W3C Trace-Context, gRPC metadata).
- Метрики для всех каналов (latency, error rate, throughput).
### Kafka
Для асинхронного взаимодействия между микросервисами используется **Apache Kafka**, так как она:
- поддерживает **высокую пропускную способность** и горизонтальное масштабирование
- подходит как для **Pub/Sub** (широковещательные события), так и для **очередей задач** (point-to-point)
- имеет встроенную **репликацию** и устойчивость к сбоям
- интегрируется с шаблоном **Transactional Outbox** для гарантированной доставки.
#### Архитектура и конфигурация кластера
- **Геораспределённый кластер**:
    - 2 брокера в регионе **МСК** (основной).
    - 1 брокер в регионе **НСК** — только реплицирует события из МСК.
- **Репликация** между регионами включена для всех критичных топиков.
- **Конфигурация для надёжности**:
    - `acks=all` — запись считается успешной, когда подтверждена всеми in-sync репликами.
    - `min.insync.replicas=2` — запись в топик возможна только при наличии минимум двух синхронных реплик.
    - Параметр `client.rack` у продюсеров и консьюмеров, чтобы читать из ближайшего брокера.
    - Топики с ключом события (например, `orderId`) для упорядоченной обработки в одном partition.
#### Сценарий 1: Pub/Sub
**Пример: обновления статусов заказов**
- **Publisher**: `order-service`
    - После изменения статуса заказа (CREATED -> PAID -> SHIPPED) отправляет событие в топик `order.status.changed`.
- **Subscribers**:
    - `notification-service` - отправка email/SMS/Push уведомлений.
    - `analytics-service` - обновление аналитической витрины.
    - `delivery-service` - подготовка к следующему шагу логистики.
- **Конфигурация**:
    - Топик `order.status.changed` - `partitions=6`, `replication.factor=3`.
    - Режим обработки: **at-least-once** (идемпотентность на стороне потребителей).
#### Сценарий 2: Point-to-Point (Модерация контента)
**Пример: обработка жалоб на объявления и пользователей**
- **Producer**: `report-service`
    - При получении жалобы от пользователя (`POST /v1/reports`) формирует задачу на проверку и отправляет её в Kafka-топик `moderation.tasks``
- **Consumers**:
    - Несколько экземпляров `moderation-service` в одной **consumer group** `moderation-workers`.
    - Каждое сообщение обрабатывается **только одним** воркером, чтобы исключить двойную проверку.
    - После обработки задача помечается как выполненная, а результат (BAN/OK) отправляется в Kafka в топик `moderation.results` (Pub/Sub для нотификаций и аналитики).
- **Конфигурация топика**: `moderation.tasks`
	- `partitions=12` (масштабируемость по воркерам)
    - `replication.factor=3` (надёжность)
    - `cleanup.policy=delete` (задачи удаляются после обработки, хранятся несколько дней для отладки)
	`moderation.results`- является publisher для уведомлений другим сервисам
#### Надёжность доставки
1. **Продюсеры**:
    - `enable.idempotence=true` — предотвращает дубликаты при ретраях.
    - `acks=all` + `min.insync.replicas=2` — запись подтверждается только при надёжной репликации.

2. **Потребители**:
    - Автокоммит смещений (`enable.auto.commit=false`), ручной коммит после успешной обработки.
    - Ретрай через повторное чтение непрочитанного сообщения.

3. **Outbox Pattern**:
    - При недоступности Kafka события временно сохраняются в таблице в БД сервиса.
    - Отдельный процесс (outbox-воркер) гарантированно отправляет их в Kafka, когда связь восстановлена.